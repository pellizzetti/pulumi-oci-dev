// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package apmsynthetics

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Monitor resource in Oracle Cloud Infrastructure Apm Synthetics service.
//
// Creates a new monitor.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-oci/sdk/go/oci/apmsynthetics"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := apmsynthetics.NewMonitor(ctx, "testMonitor", &apmsynthetics.MonitorArgs{
// 			ApmDomainId:             pulumi.Any(oci_apm_synthetics_apm_domain.Test_apm_domain.Id),
// 			DisplayName:             pulumi.Any(_var.Monitor_display_name),
// 			MonitorType:             pulumi.Any(_var.Monitor_monitor_type),
// 			RepeatIntervalInSeconds: pulumi.Any(_var.Monitor_repeat_interval_in_seconds),
// 			VantagePoints: pulumi.StringArray{
// 				nil,
// 			},
// 			Configuration: &apmsynthetics.MonitorConfigurationArgs{
// 				ConfigType:                     pulumi.Any(_var.Monitor_configuration_config_type),
// 				IsCertificateValidationEnabled: pulumi.Any(_var.Monitor_configuration_is_certificate_validation_enabled),
// 				IsFailureRetried:               pulumi.Any(_var.Monitor_configuration_is_failure_retried),
// 				IsRedirectionEnabled:           pulumi.Any(_var.Monitor_configuration_is_redirection_enabled),
// 				ReqAuthenticationDetails: &apmsynthetics.MonitorConfigurationReqAuthenticationDetailsArgs{
// 					AuthHeaders: apmsynthetics.MonitorConfigurationReqAuthenticationDetailsAuthHeaderArray{
// 						&apmsynthetics.MonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs{
// 							HeaderName:  pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_headers_header_name),
// 							HeaderValue: pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_headers_header_value),
// 						},
// 					},
// 					AuthRequestMethod:   pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_request_method),
// 					AuthRequestPostBody: pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_request_post_body),
// 					AuthToken:           pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_token),
// 					AuthUrl:             pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_url),
// 					AuthUserName:        pulumi.Any(oci_identity_user.Test_user.Name),
// 					AuthUserPassword:    pulumi.Any(_var.Monitor_configuration_req_authentication_details_auth_user_password),
// 					OauthScheme:         pulumi.Any(_var.Monitor_configuration_req_authentication_details_oauth_scheme),
// 				},
// 				ReqAuthenticationScheme: pulumi.Any(_var.Monitor_configuration_req_authentication_scheme),
// 				RequestHeaders: apmsynthetics.MonitorConfigurationRequestHeaderArray{
// 					&apmsynthetics.MonitorConfigurationRequestHeaderArgs{
// 						HeaderName:  pulumi.Any(_var.Monitor_configuration_request_headers_header_name),
// 						HeaderValue: pulumi.Any(_var.Monitor_configuration_request_headers_header_value),
// 					},
// 				},
// 				RequestMethod:   pulumi.Any(_var.Monitor_configuration_request_method),
// 				RequestPostBody: pulumi.Any(_var.Monitor_configuration_request_post_body),
// 				RequestQueryParams: apmsynthetics.MonitorConfigurationRequestQueryParamArray{
// 					&apmsynthetics.MonitorConfigurationRequestQueryParamArgs{
// 						ParamName:  pulumi.Any(_var.Monitor_configuration_request_query_params_param_name),
// 						ParamValue: pulumi.Any(_var.Monitor_configuration_request_query_params_param_value),
// 					},
// 				},
// 				VerifyResponseCodes:   pulumi.Any(_var.Monitor_configuration_verify_response_codes),
// 				VerifyResponseContent: pulumi.Any(_var.Monitor_configuration_verify_response_content),
// 				VerifyTexts: apmsynthetics.MonitorConfigurationVerifyTextArray{
// 					&apmsynthetics.MonitorConfigurationVerifyTextArgs{
// 						Text: pulumi.Any(_var.Monitor_configuration_verify_texts_text),
// 					},
// 				},
// 			},
// 			DefinedTags: pulumi.AnyMap{
// 				"foo-namespace.bar-key": pulumi.Any("value"),
// 			},
// 			FreeformTags: pulumi.AnyMap{
// 				"bar-key": pulumi.Any("value"),
// 			},
// 			ScriptId: pulumi.Any(oci_apm_synthetics_script.Test_script.Id),
// 			ScriptParameters: apmsynthetics.MonitorScriptParameterArray{
// 				&apmsynthetics.MonitorScriptParameterArgs{
// 					ParamName:  pulumi.Any(_var.Monitor_script_parameters_param_name),
// 					ParamValue: pulumi.Any(_var.Monitor_script_parameters_param_value),
// 				},
// 			},
// 			Status:           pulumi.Any(_var.Monitor_status),
// 			Target:           pulumi.Any(_var.Monitor_target),
// 			TimeoutInSeconds: pulumi.Any(_var.Monitor_timeout_in_seconds),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Monitors can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import oci:apmsynthetics/monitor:Monitor test_monitor "monitors/{monitorId}/apmDomainId/{apmDomainId}"
// ```
type Monitor struct {
	pulumi.CustomResourceState

	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringOutput `pulumi:"apmDomainId"`
	// (Updatable) Details of monitor configuration.
	Configuration MonitorConfigurationOutput `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapOutput `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapOutput `pulumi:"freeformTags"`
	// Type of monitor.
	MonitorType pulumi.StringOutput `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds.
	RepeatIntervalInSeconds pulumi.IntOutput `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringOutput `pulumi:"scriptId"`
	// Name of the script.
	ScriptName pulumi.StringOutput `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters MonitorScriptParameterArrayOutput `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringOutput `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
	Target pulumi.StringOutput `pulumi:"target"`
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated pulumi.StringOutput `pulumi:"timeCreated"`
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated pulumi.StringOutput `pulumi:"timeUpdated"`
	// (Updatable) Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntOutput `pulumi:"timeoutInSeconds"`
	// Number of vantage points where monitor is running.
	VantagePointCount pulumi.IntOutput `pulumi:"vantagePointCount"`
	// (Updatable) A list of vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points.
	VantagePoints pulumi.StringArrayOutput `pulumi:"vantagePoints"`
}

// NewMonitor registers a new resource with the given unique name, arguments, and options.
func NewMonitor(ctx *pulumi.Context,
	name string, args *MonitorArgs, opts ...pulumi.ResourceOption) (*Monitor, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApmDomainId == nil {
		return nil, errors.New("invalid value for required argument 'ApmDomainId'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.MonitorType == nil {
		return nil, errors.New("invalid value for required argument 'MonitorType'")
	}
	if args.RepeatIntervalInSeconds == nil {
		return nil, errors.New("invalid value for required argument 'RepeatIntervalInSeconds'")
	}
	if args.VantagePoints == nil {
		return nil, errors.New("invalid value for required argument 'VantagePoints'")
	}
	var resource Monitor
	err := ctx.RegisterResource("oci:apmsynthetics/monitor:Monitor", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMonitor gets an existing Monitor resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMonitor(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MonitorState, opts ...pulumi.ResourceOption) (*Monitor, error) {
	var resource Monitor
	err := ctx.ReadResource("oci:apmsynthetics/monitor:Monitor", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Monitor resources.
type monitorState struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId *string `pulumi:"apmDomainId"`
	// (Updatable) Details of monitor configuration.
	Configuration *MonitorConfiguration `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags map[string]interface{} `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName *string `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]interface{} `pulumi:"freeformTags"`
	// Type of monitor.
	MonitorType *string `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds.
	RepeatIntervalInSeconds *int `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId *string `pulumi:"scriptId"`
	// Name of the script.
	ScriptName *string `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters []MonitorScriptParameter `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status *string `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
	Target *string `pulumi:"target"`
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated *string `pulumi:"timeCreated"`
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated *string `pulumi:"timeUpdated"`
	// (Updatable) Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds *int `pulumi:"timeoutInSeconds"`
	// Number of vantage points where monitor is running.
	VantagePointCount *int `pulumi:"vantagePointCount"`
	// (Updatable) A list of vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points.
	VantagePoints []string `pulumi:"vantagePoints"`
}

type MonitorState struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringPtrInput
	// (Updatable) Details of monitor configuration.
	Configuration MonitorConfigurationPtrInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapInput
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringPtrInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapInput
	// Type of monitor.
	MonitorType pulumi.StringPtrInput
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds.
	RepeatIntervalInSeconds pulumi.IntPtrInput
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringPtrInput
	// Name of the script.
	ScriptName pulumi.StringPtrInput
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters MonitorScriptParameterArrayInput
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringPtrInput
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
	Target pulumi.StringPtrInput
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated pulumi.StringPtrInput
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated pulumi.StringPtrInput
	// (Updatable) Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntPtrInput
	// Number of vantage points where monitor is running.
	VantagePointCount pulumi.IntPtrInput
	// (Updatable) A list of vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points.
	VantagePoints pulumi.StringArrayInput
}

func (MonitorState) ElementType() reflect.Type {
	return reflect.TypeOf((*monitorState)(nil)).Elem()
}

type monitorArgs struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId string `pulumi:"apmDomainId"`
	// (Updatable) Details of monitor configuration.
	Configuration *MonitorConfiguration `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags map[string]interface{} `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName string `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]interface{} `pulumi:"freeformTags"`
	// Type of monitor.
	MonitorType string `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds.
	RepeatIntervalInSeconds int `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId *string `pulumi:"scriptId"`
	// Name of the script.
	ScriptName *string `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters []MonitorScriptParameter `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status *string `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
	Target *string `pulumi:"target"`
	// (Updatable) Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds *int `pulumi:"timeoutInSeconds"`
	// (Updatable) A list of vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points.
	VantagePoints []string `pulumi:"vantagePoints"`
}

// The set of arguments for constructing a Monitor resource.
type MonitorArgs struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringInput
	// (Updatable) Details of monitor configuration.
	Configuration MonitorConfigurationPtrInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapInput
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapInput
	// Type of monitor.
	MonitorType pulumi.StringInput
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds.
	RepeatIntervalInSeconds pulumi.IntInput
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringPtrInput
	// Name of the script.
	ScriptName pulumi.StringPtrInput
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters MonitorScriptParameterArrayInput
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringPtrInput
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
	Target pulumi.StringPtrInput
	// (Updatable) Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntPtrInput
	// (Updatable) A list of vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points.
	VantagePoints pulumi.StringArrayInput
}

func (MonitorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*monitorArgs)(nil)).Elem()
}

type MonitorInput interface {
	pulumi.Input

	ToMonitorOutput() MonitorOutput
	ToMonitorOutputWithContext(ctx context.Context) MonitorOutput
}

func (*Monitor) ElementType() reflect.Type {
	return reflect.TypeOf((*Monitor)(nil))
}

func (i *Monitor) ToMonitorOutput() MonitorOutput {
	return i.ToMonitorOutputWithContext(context.Background())
}

func (i *Monitor) ToMonitorOutputWithContext(ctx context.Context) MonitorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitorOutput)
}

func (i *Monitor) ToMonitorPtrOutput() MonitorPtrOutput {
	return i.ToMonitorPtrOutputWithContext(context.Background())
}

func (i *Monitor) ToMonitorPtrOutputWithContext(ctx context.Context) MonitorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitorPtrOutput)
}

type MonitorPtrInput interface {
	pulumi.Input

	ToMonitorPtrOutput() MonitorPtrOutput
	ToMonitorPtrOutputWithContext(ctx context.Context) MonitorPtrOutput
}

type monitorPtrType MonitorArgs

func (*monitorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Monitor)(nil))
}

func (i *monitorPtrType) ToMonitorPtrOutput() MonitorPtrOutput {
	return i.ToMonitorPtrOutputWithContext(context.Background())
}

func (i *monitorPtrType) ToMonitorPtrOutputWithContext(ctx context.Context) MonitorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitorPtrOutput)
}

// MonitorArrayInput is an input type that accepts MonitorArray and MonitorArrayOutput values.
// You can construct a concrete instance of `MonitorArrayInput` via:
//
//          MonitorArray{ MonitorArgs{...} }
type MonitorArrayInput interface {
	pulumi.Input

	ToMonitorArrayOutput() MonitorArrayOutput
	ToMonitorArrayOutputWithContext(context.Context) MonitorArrayOutput
}

type MonitorArray []MonitorInput

func (MonitorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Monitor)(nil)).Elem()
}

func (i MonitorArray) ToMonitorArrayOutput() MonitorArrayOutput {
	return i.ToMonitorArrayOutputWithContext(context.Background())
}

func (i MonitorArray) ToMonitorArrayOutputWithContext(ctx context.Context) MonitorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitorArrayOutput)
}

// MonitorMapInput is an input type that accepts MonitorMap and MonitorMapOutput values.
// You can construct a concrete instance of `MonitorMapInput` via:
//
//          MonitorMap{ "key": MonitorArgs{...} }
type MonitorMapInput interface {
	pulumi.Input

	ToMonitorMapOutput() MonitorMapOutput
	ToMonitorMapOutputWithContext(context.Context) MonitorMapOutput
}

type MonitorMap map[string]MonitorInput

func (MonitorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Monitor)(nil)).Elem()
}

func (i MonitorMap) ToMonitorMapOutput() MonitorMapOutput {
	return i.ToMonitorMapOutputWithContext(context.Background())
}

func (i MonitorMap) ToMonitorMapOutputWithContext(ctx context.Context) MonitorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitorMapOutput)
}

type MonitorOutput struct {
	*pulumi.OutputState
}

func (MonitorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Monitor)(nil))
}

func (o MonitorOutput) ToMonitorOutput() MonitorOutput {
	return o
}

func (o MonitorOutput) ToMonitorOutputWithContext(ctx context.Context) MonitorOutput {
	return o
}

func (o MonitorOutput) ToMonitorPtrOutput() MonitorPtrOutput {
	return o.ToMonitorPtrOutputWithContext(context.Background())
}

func (o MonitorOutput) ToMonitorPtrOutputWithContext(ctx context.Context) MonitorPtrOutput {
	return o.ApplyT(func(v Monitor) *Monitor {
		return &v
	}).(MonitorPtrOutput)
}

type MonitorPtrOutput struct {
	*pulumi.OutputState
}

func (MonitorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Monitor)(nil))
}

func (o MonitorPtrOutput) ToMonitorPtrOutput() MonitorPtrOutput {
	return o
}

func (o MonitorPtrOutput) ToMonitorPtrOutputWithContext(ctx context.Context) MonitorPtrOutput {
	return o
}

type MonitorArrayOutput struct{ *pulumi.OutputState }

func (MonitorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Monitor)(nil))
}

func (o MonitorArrayOutput) ToMonitorArrayOutput() MonitorArrayOutput {
	return o
}

func (o MonitorArrayOutput) ToMonitorArrayOutputWithContext(ctx context.Context) MonitorArrayOutput {
	return o
}

func (o MonitorArrayOutput) Index(i pulumi.IntInput) MonitorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Monitor {
		return vs[0].([]Monitor)[vs[1].(int)]
	}).(MonitorOutput)
}

type MonitorMapOutput struct{ *pulumi.OutputState }

func (MonitorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Monitor)(nil))
}

func (o MonitorMapOutput) ToMonitorMapOutput() MonitorMapOutput {
	return o
}

func (o MonitorMapOutput) ToMonitorMapOutputWithContext(ctx context.Context) MonitorMapOutput {
	return o
}

func (o MonitorMapOutput) MapIndex(k pulumi.StringInput) MonitorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Monitor {
		return vs[0].(map[string]Monitor)[vs[1].(string)]
	}).(MonitorOutput)
}

func init() {
	pulumi.RegisterOutputType(MonitorOutput{})
	pulumi.RegisterOutputType(MonitorPtrOutput{})
	pulumi.RegisterOutputType(MonitorArrayOutput{})
	pulumi.RegisterOutputType(MonitorMapOutput{})
}
